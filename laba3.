from collections import deque
import time

class ArrayQueue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        return self.items.pop(0) if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0

class LinkedListQueue:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
    
    def __init__(self):
        self.front = None
        self.rear = None
    
    def enqueue(self, item):
        new_node = self.Node(item)
        if self.rear is None:
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
    
    def dequeue(self):
        if self.front is None:
            return None
        temp = self.front
        self.front = temp.next
        if self.front is None:
            self.rear = None
        return temp.data
    
    def is_empty(self):
        return self.front is None

class StdLibQueue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        return self.items.popleft() if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0

def calculate_water_after_lifting(matrix):
    if len(matrix) < 3 or len(matrix[0]) < 3:
        return 0
        
    m, n = len(matrix), len(matrix[0])
    water_level = [[float('inf')] * n for _ in range(m)]
    queue = deque()
    
    for i in range(m):
        for j in range(n):
            if i == 0 or i == m-1 or j == 0 or j == n-1:
                water_level[i][j] = matrix[i][j]
                queue.append((i, j))
    
    while queue:
        i, j = queue.popleft()
        for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
            ni, nj = i + di, j + dj
            if 0 <= ni < m and 0 <= nj < n:
                new_level = max(matrix[ni][nj], water_level[i][j])
                if water_level[ni][nj] > new_level:
                    water_level[ni][nj] = new_level
                    queue.append((ni, nj))
    
    volume = 0
    for i in range(m):
        for j in range(n):
            volume += water_level[i][j] - matrix[i][j]
    
    return volume

def pour_water(matrix, i0, j0, V, queue_impl):
    m, n = len(matrix), len(matrix[0])
    water = [[0] * n for _ in range(m)]
    leaked = 0

    for _ in range(V):
        if pour_one_drop(matrix, water, i0, j0, queue_impl):
            leaked += 1

    total_added = V - leaked
    print(f"Из {V} единиц воды добавлено {total_added}, вытекло {leaked}")
    
    result = []
    for i in range(m):
        row = []
        for j in range(n):
            row.append(matrix[i][j] + water[i][j])
        result.append(row)
    return result

def pour_one_drop(matrix, water, i0, j0, queue_impl):
    m, n = len(matrix), len(matrix[0])
    visited = [[False] * n for _ in range(m)]
    queue = queue_impl()
    
    queue.enqueue((i0, j0))
    visited[i0][j0] = True
    min_level = float('inf')
    min_cells = []
    found_boundary = False

    while not queue.is_empty():
        i, j = queue.dequeue()
        
        if i == 0 or i == m-1 or j == 0 or j == n-1:
            found_boundary = True
            break
            
        for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
            ni, nj = i + di, j + dj
            if not (0 <= ni < m and 0 <= nj < n) or visited[ni][nj]:
                continue
                
            current_level = matrix[i][j] + water[i][j]
            neighbor_level = matrix[ni][nj] + water[ni][nj]
            
            if neighbor_level <= current_level:
                visited[ni][nj] = True
                queue.enqueue((ni, nj))
                
                if neighbor_level < min_level:
                    min_level = neighbor_level
                    min_cells = [(ni, nj)]
                elif neighbor_level == min_level:
                    min_cells.append((ni, nj))
    
    if found_boundary:
        return 1
    else:
        if min_cells:
            i_min, j_min = min_cells[0]
        else:
            i_min, j_min = i0, j0
        water[i_min][j_min] += 1
        return 0

def input_matrix():
    while True:
        try:
            m = int(input("Введите количество строк матрицы (M >= 3): "))
            n = int(input("Введите количество столбцов матрицы (N >= 3): "))
            if m < 3 or n < 3:
                print("Размеры должны быть не менее 3x3!")
                continue
            
            print(f"\nВведите матрицу {m}x{n} (построчно, числа через пробел):")
            matrix = []
            for i in range(m):
                while True:
                    row = input(f"Строка {i+1}: ").strip().split()
                    if len(row) != n:
                        print(f"Ожидается {n} чисел!")
                        continue
                    try:
                        row = [int(num) for num in row]
                        matrix.append(row)
                        break
                    except ValueError:
                        print("Все элементы должны быть целыми числами!")
            return matrix
        except ValueError:
            print("Пожалуйста, введите целые числа!")

def print_matrix(matrix):
    for row in matrix:
        print(" ".join(map(str, row)))

def benchmark_queue(queue_impl, size=10000):
    start = time.time()
    q = queue_impl()
    for i in range(size):
        q.enqueue(i)
    for i in range(size):
        q.dequeue()
    return time.time() - start

def main():
    print("Программа расчета объема воды в форме")
    matrix = input_matrix()
    
    while True:
        print("\nМеню:")
        print("1. Рассчитать объем воды после полного погружения и подъема")
        print("2. Залить воду в конкретную точку")
        print("3. Сравнить производительность реализаций очереди")
        print("4. Ввести новую матрицу")
        print("5. Выход")
        
        choice = input("Выберите действие: ")
        
        if choice == "1":
            volume = calculate_water_after_lifting(matrix)
            print(f"\nОбъем оставшейся воды: {volume}")
        
        elif choice == "2":
            try:
                print("\nТекущая матрица:")
                print_matrix(matrix)
                
                i = int(input(f"\nВведите строку точки заливки (от 1 до {len(matrix)}): ")) - 1
                j = int(input(f"Введите столбец точки заливки (от 1 до {len(matrix[0])}): ")) - 1
                
                if not (0 <= i < len(matrix) and 0 <= j < len(matrix[0])):
                    print("Неверные координаты!")
                    continue
                
                v = int(input("Введите объем воды для заливки: "))
                if v <= 0:
                    print("Объем должен быть положительным!")
                    continue
                
                print("\nВыберите реализацию очереди:")
                print("1 - Массив")
                print("2 - Связанный список")
                print("3 - Стандартная библиотека")
                impl_choice = input("Ваш выбор: ")
                
                if impl_choice == "1":
                    queue = ArrayQueue
                elif impl_choice == "2":
                    queue = LinkedListQueue
                elif impl_choice == "3":
                    queue = StdLibQueue
                else:
                    print("Неверный выбор!")
                    continue
                
                result = pour_water(matrix, i, j, v, queue)
                print("\nРезультат заливки:")
                print_matrix(result)
            
            except ValueError:
                print("Ошибка ввода данных!")
        
        elif choice == "3":
            sizes = [1000, 10000, 100000]
            print("\nТестирование производительности:")
            print("Размер | Массив | Список | STL")
            for size in sizes:
                t_arr = benchmark_queue(ArrayQueue, size)
                t_list = benchmark_queue(LinkedListQueue, size)
                t_std = benchmark_queue(StdLibQueue, size)
                print(f"{size:6} | {t_arr:.5f} | {t_list:.5f} | {t_std:.5f}")
        
        elif choice == "4":
            matrix = input_matrix()
        
        elif choice == "5":
            print("Выход из программы")
            break
        
        else:
            print("Неверный выбор!")

if __name__ == "__main__":
    main()
